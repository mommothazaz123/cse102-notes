09:22:03 >>Professor:  good morning everyone.  We will get started in just a minute.  All right good morning everyone.  Last time we talked about another example of a divide and conquer algorithm.  This one was for integer multiplication.  This multiplication algorithm.  To recap how that worked the basic idea was if we had two N bit integers X and Y we will divide them in the most natural way.  We take the entire bit and split them in half.
09:22:52 We look at the first half and second half of their bit.  We wrote that like this.  Saying X and Y we can split them in X one and Y zero.  X one is the first N over two digit.  In base two it works the same way.  X zero is the latter N over two digits of the number.  Having done that what we showed was with a little algebra how you can express the production we want X times Y in terms of X one and Y one.  It required four multiplications of the smaller N over two digit numbers.
09:23:30 It didn't yield an algorithm that was faster than the standard multiplication algorithm.  Than there was this trick where if we compute the product of X one plus X zero with Y one plus Y zero we could extract all of the productions we needed using only three multiplications recursively and plug them in this formula to get the product we wanted.  That led to this algorithm that we wrote last time.  Because this algorithm only made three recursive calls
09:24:05 To multiply N over two digit numbers we got this recurrence which said we have to make three calls to multiply numbers of N over two digits plus a linear amount of extra work.  We had to do a couple additions here.  We had to do subtraction here.  We had to do shifting by N zeros over here.  All that could be done in linear time.  That gave us this recurrence.  Plugging that in the master theorem for divide and conquer recurrences we got the solution.
09:24:42 N to the log base two of three which is N to the one point five eight.  That was faster than the N squared algorithm we learn in school.  This is another nice example of how the divide and conquer approach can yield a faster algorithm in some cases.  Here what we had to do was figure out given the splitting of these two numbers in to the two halfs how can we use the results of some recursive smaller multiplications to compute the number we actually wanted.
09:25:12 This illustrates part of the design process for divide and conquer algorithm where often there's a strait forward way to split the problem in smaller ones.  Here it was a natural idea to take these two integers and split them in half.  The question you just have to figure out when designing the algorithm is how can you write the answer that you actually want.  Here the production of X and Y in terms of those smaller subproblems.
09:25:58 In terms of some multiplications involving X one, X zero Y one and Y zero.  Someone said in the chat I did post the recording of the last lecture but forgot to upload the notes.  I will do that after class.  This was another example of the divide and conquer approach.  I want to give you one more example today so you can see another instance how the divide and conquer approach gives faster algorithms and help you solve problem where it's not clear how you can do
09:26:56 Better than the naive approach.  Let's look at that example.  This is for another problem in computational geometry.  This problem is for finding the closest pair of points in the plain.  For details on this problem there's a nice description in both of our text books.  I will put that here if you want to look that up.  What is this problem?  The idea is we are given a set of N points in the plain like in the convex hull problem.
09:28:02 We have N points.  We have the X and Y coordinates.  I will draw a picture here.  We are given this set of points.  We have X and Y coordinates for these.  The question is find the pair of points closest together.  In this example it would be these two points.  Those two are closer to each other than any other pair of points.  This is useful in computer graphics and planning problems.  You can imagine you have a set of power stations
09:28:34 Or something like that.  You are trying to find which two are closest together so you can see if we should merge those two and not actually build both of those power stations.  This is the problem.  Straight forward algorithm you could think of for doing this is to check all possible pairs of points.  We have N points.  Let's look at the pairs.  We will compute the distances between them and see which has the least distance.
09:29:44 The naive algorithm.  Check all possible pairs.  You compute the distance.  Take the pair with the least distance.  How long would this take asymptoticly if we have N points?  Any suggestions for the run time.  It would be N squared.  This would take in the worst case this would take N square time.  On the order of N squared pairs.  The number of pairs is N choose two.  Which is N times N minus one over two.  That's theta of N squared.
09:30:21 You need to find, you have to check all possible pairs.  You don't know which will have the least distance.  You have to compute N squared many distances.  Each distance takes constant time.  That's some math to compute, they use the Pythagorean theorem to compute the distance.  The that's the natural algorithm.  If the set of points is not too big this is fine.  If you have millions of points this will take a very long time.
09:30:59 It may seem like how could you improve on this because you do need to check all possible pairs of points in the sense that every pair of points could be the one with the least distance.  On the other hand, given a set of points like this it's clear that this point and this point can't be the closest pair because these points are in between those.  If this were the closest with that this would be closer.  Strictly closer.  That's not possible.  We have to use some information about how thes point
09:31:42 Are spread out to get a faster algorithm.  It's not clear how to do that.  The nice thing about divide and conquer is it takes away this issue of thinking about how do we design the whole algorithm.  With divide and conquer because you get the recursive calls for free all we have to think about is the way to split up the problem and the way to recombine the results.  Let's see how we can do that in this case.  We need to figure out those two things I just mentioned.
09:32:21 How to split the problem and how to recombine the results.  For this problem there's a natural way of splitting it up which is just the same as what we did for the convex hull problem.  Namely, let's just draw some line dividing the set of points in half.  We have those on the left and those on the right.  To divide let's take the left and right halves of the points.  Just like we did in the convex hull algorithm.  This is the most natural way to split them up.
09:32:59 How can we actually do this splitting?  We are going to need to be able to not only draw a dividing line to split the points in half to begin with.  For example, here this is one dividing line with four points on the left and right.  Recursively we have to divide the left and right halves up as well.  In order to be able to efficiently divide those up we could start by sorting all of these points by the X coordinate.  Then if we look halfway along the list that tells you
09:33:50 We will split here.  Recursively we can look a quarter of the way along the list, three quarters of the way and so forth.  In order to do this efficiently we will start before we do the recursion we will start by sorting the points by their X coordinate.  Question.  What if we divided along the Y axis instead?  That works just as well.  It's arbitrary here.  I'm going to divide by the X coordinate because that's how it's written in the book.  You are right.
09:34:54 It's fine to draw a line that splits them in the top and bottom half.  The points, there's no difference between the X and Y coordinate in the set up of this problem.  It's symmetric.  Once we have assorted the points by their X coordinate then the first half of the assorted array, the points we put them in an array assorted by X coordinate.  The first half of the assorted array has the left most N over two points.  The second half has the N over two right most points.
09:35:44 Where as usual it could be N over two with a floor or ceiling but we will not worry about that.  We assume N is power of two so we evenly divided the points on the left and right-hand sides.  If we decide this is how we are going to do the division then as usual in a divide and conquer algorithm we get for free that the recursive calls work correctly.  Then we can use recursive calls to find the closest pair of points on the left-hand side and the closest pair on the right-hand side.
09:36:43 In this example up here this was the actual closest pair.  Because I drew the line there to have the four points on the left and right the recursive call on the left will find the closest pair on the left which in this case looks like it's these two points.  On the right-hand side the closest pair is these two points.  What this is illustrating here is that it's not enough to just look at the recursive calls and see which ever pair you found was closest.  Of this pair and this pair these t close
09:37:21 But we missed the real closest pair because that has one point on the left-hand side and one point on the right-hand side.  When doing this recombination we need to check for the possibility that the closest pair spans this dividing line.  Everyone see that?  We are not going to just be able to take the results of the recursive call and say return which ever pair is closest.  We have to worry about pairs we have not yet considered because they have one point on one side.
09:38:32 The other point is on the other side.  How do we deal with that?  Let's draw another picture here.  The problem, to restate that, we have not considered pairs where one point is in the left half and the other is in the right half.  As we saw in that picture.  How are we going to deal with this?  First idea you may have would be, if I bring the diagram back for a second, one thing you could try is why don't we look at all the pairs of this.
09:39:03 Where you have one pair on the left and right.  For these points we check it against all four points over there.  The problem with that is there are N over two points over here.  To check them against all N over two points over here you have to do N over two times N over two distance computations.  That would be N squared over four.  That's still order N squared.  Asymptoticly that will not help us.  It's better than N squared.  It's better than this.
09:40:19 It's not that much better.  Asymptoticly it's still quadratic.  We need to do something more clever than checking all points on the left against all points on the right.  Checking all pairs of this form would again be theta of N squared which we don't want.  Instead the idea is we will filter out many pairs which can't be the closest.  How do we do this?  Let me draw a new diagram.  Let's say here's the dividing line we had.  Zooming in on the old diagram.
09:41:16 We recursively divide the the points in the left and right.  We are worried there could be a closest point (INDISCERNIBLE) and these two are actually closer together than any other pair.  The first observation to make is if we have a point way out here for example and let's say there was a point, suppose on the right-hand side this was the closest pair.  Our recursive call will find this pair as being the closest on that side.  If this is this distance let's call this delta R.
09:41:55 This is the smallest distance on the right-hand side.  The first observation is that we don't have to consider either of these two points compared against this one.  Because they are more than distance delta R away from this line.  If we want to check whether this point can be closest to anything over here.  If you have a point further than delta R away from this line the distance on the left-hand side has to be at least delta R.  That pair will be further apart than
09:43:02 This pair we already found.  Likewise, if we have a closest pair over here let's say this is the closest pair on the left we call that delta L.  Likewise, we can ignore all the points which are further away from this line than delta L.  The first idea is if the recursive calls find pairs at distances delta L and delta R respectively.  On the left-hand side the closest pair has a distance of delta L and on the right-hand side the close e- pair has a distance of delta R.
09:43:56 Then we can ignore all points that are further than delta.  Which ever of these is smaller.  Delta L, delta R from the dividing line.  A question of how do we determine where the dividing line is.  It's true that I said we are splitting the points in half.  I have not said exactly where the dividing line is.  The exact position of this line doesn't matter as long as -- if there's N over two points to the left and right it has to be somewhere between these points.
09:44:30 The exact position will not matter.  We can say to make it precise that we draw it halfway between these two points.  It will not actually matter.  Good observation.  The way we are doing the split as I described it before was we are taking the left N over two points and the right N over two points.  I have not said where to draw the line.  It's half between the right most of the left half of the points and left most of the right half of the points.
09:45:23 The first observation is if we look out a distance delta in both directions then we can draw this tube here.  We don't have to worry about any pairs that are outside of this region.  Anything that is outside of this region has it be a distance at least delta from the center line and so it's a distance at least delta from any point on the other side of the dividing line.  If we are looking for this pair where one point is on the left half and the other is on the rite,
09:46:22 We are worried if such a pair could be closer together than this pair and this pair.  It suffices to consider (INDISCERNIBLE) that are in this tube near the center of the dividing line.  Any questions about this?  Now we eliminated some pairs we don't have to check.  For this point on the left we don't have to look at all the points here.  We only look at the ones in this tube here.  Question.  If we find a smaller pair does delta decrease once again?
09:46:55 Here we assume because it's divide and conquer that the recursive calls have found the closest pairs on the left-hand side and right-hand side.  This is the closest pair on the left-hand side and this is the close est pair on the right-hand side.  We know that because of the recursive call.  Look at which ever pair is closer and we will call that delta.  Now for looking at these pairs that span the dividing line we need to make sure -- we are trying to check
09:47:37 Is there any pair that spans the center line that's closer than delta together.  What I'm saying is we can restrict our attention to this tube here.  If you have a point outside of this tube it can't be closer to delta to anything on the other side of the dividing line.  That's the first observation.  We eliminated points on the left and right-hand side.  The second observation is if we have a point further down or above than this point.
09:48:07 Again, we shouldn't have to consider this point because it's going to be too far away.  Question before we move on.  Why are we looking at a distance of two times delta?  The ideas is we are trying to see for this particular point let's say we are considering this point.  We are trying to look at which points on the right-hand side can it possibly be matched up with to get a distance less than delta.  We only need to consider points on the right-hand side.
09:48:41 That are within delta of the dividing line.  If they are beyond that point they have to have distance certainly bigger than delta to this point.  That let's us eliminate everything over here.  We just have things in this tube.  Everything here could be within distance delta to this point.  For this particular point why not look for everything within delta of that point of the we don't have a way of finding those points unless we compute all the distances.
09:49:19 That's what we want to avoid.  We want to avoid comparing this point against everything here.  We want to be able to eliminate most of the points so we don't have to do N squared amount of checks.  The first thing we are going to do is we will only keep all the points on the right-hand side that are within distance delta of the dividing line.  We can do that because we have these points assorted by X coordinate.  What we can do is start with the one closest
09:50:23 To the dividing line and keep iterating through until we exceed distance delta from the dividing line.  From that point all the rest of them are further away.  In linear time we can find the points in this tube here.  We can find the remaining points in linear time.  In fact, we don't need to compute all the distances again.  We have them assorted in the list.  This question why are we not looking at all the points delta away from this point?
09:51:01 It would take quadratic time.  If for every point we have to compute which points are within delta of that point that would be N squared.  We have to take all the points on the right compute the distances to this point and compute the distance to this point et cetera that would be N squared.  We don't want to do that.  Here's the next idea.  The next idea is that there's a quick way to eliminate points too far above or be low compared to this point.
09:51:50 The way we do that is by drawing some hypothetical boxes in here of size delta over two.  The idea is we know that the closest pair of points on the left-hand side is delta L apart.  Here it's delta R apart.  On the left-hand side and right-hand side there's no pair of points within distance delta less than delta of each other.  The close e- pair of points on the left-hand side and right-hand side have distance delta to each other.  Every pair of points has distance at least delta.
09:53:06 On the left-hand side and right-hand side.  What we will do is if we draw some boxes around these points of size delta over two.  Let's do that.  We will cut this in half again.  We will cut the delta over here in half again.  Let's draw these boxes.  We will say here, imagine drawing these boxes where each of the squares has size delta over two.  Why are we doing this?  If we draw these boxes notice that the distance between any two points inside this square is at most what?
09:54:06 If we have a square of size delta over two by delta over two what's the diagonal?  The diagonal is using the Pythagorean theorem it's delta over two squared plus delta over two squared.  Square root.  This is delta times square root two over two.  Which is strictly less than delta.  Since it's a square the diagonal is root two times the size.  You have delta times root two over two which is less than one.  This box any two points inside a box have distance strictly less than
09:55:22 Delta from each other.  We know from the the recursive calls there are no points on the left-hand side that are within delta -- less than delta distance from each other.  The same on the right-hand side.  Second idea on both the left and right no pairs are closer than delta together by the recursive call.  If we draw boxes of size delta over two there's at most one point per box.  We are drawing these boxes around the dividing line.
09:56:10 These eight boxes are on the left and right.  On both the left and right we know no pairs are closer to each other than distance delta.  Since the diameter of this box if we look at the diagonal is less than delta that means there's at most one point in each of these boxes.  Does everyone see that?  Question.  Could we do delta over three instead since it's also less than delta?  We could have.  I wanted to draw as few boxes as possible.
09:56:48 There are ways of improving this argument which I will not get to.  There's a discussion in the book, but delta over two is small enough that we get the one point per box.  If we divide it in smaller boxes there's still at most one point in each box.  I want there to be as few of these boxes as possible.  What's the point of drawing these boxes?  Now that we know there's at most one point in each box notice that this allows us to decrease the number of points we have to compare
09:57:22 To this one with the arrow.  Question.  Explain why there's at most one point in the box.  If there were two points in the box then they have to have distance less than delta apart.  Because the side of the box is only delta over two.  The worse case is they are in opposite corners of the box.  The distance is delta times root two over two which is less than delta.  We know there cannot be points on the left-hand side and right-hand side.
09:57:53 That are closer than delta together.  Because by definition delta is the closest distance between any pair of points on the left-hand side and right-hand side.  That's how we define delta.  Our recursive call told us on the left-hand side there are no points closer than delta L to each other.  On the right-hand side there are no points closer than delta R to each other.  If we take which of those is smaller then we know there are no points closer to each other than delta.
09:58:32 Delta is the minimum distance between any two points on the left-hand side or right-hand side.  There could be one point on the left and right that are closer than delta to each other.  That's what we are trying to finds.  I'm drawing these boxes with the dividing line.  Each box has points only from the left-hand side or right-hand side.  On the box on the left if it has two points on this box that's two (INDISCERNIBLE).  If there's two points on this box
09:59:26 There's two points on the right-hand side at distance less than delta which is again impossible.  It's important that I'm drawing these boxes so they are either completely on the left-hand side or right-hand side.  Further questions about this?  We know there's at most one point in each of these boxes.  How is this going to help us?  The observation is that if you have a point on the left-hand side that is within distance delta of appoint on the right-hand side,
10:00:07 It can't be too many boxes away.  In fact, if we imagine taking all the points on the right-hand side.  Remember we have to restrict ourselves to points in this tube.  If we took this point suppose we sort them by the Y coordinate.  We start here and move up ward.  We look at them in order as you move up this tube.  We know there's at most one point in each of these boxes.  There could be appoint here or there.  There aren't two points in any of these books.
10:00:46 How many points in the worst case do we have to look at to compare against this point here?  Well, in order for it to be within distance delta of that point it has to be in one of I think it works out to fifteen of the closest boxes.  It could be in any of these boxes here.  It can be in any of these boxes as well.  Suppose we have a point in this box.  If you have appoint in this box when's the minimum distance it can be from this point?
10:01:50 It could be in this corner.  In which case if you move across by this box then this box that's already distance delta.  It can't be within distance delta of this point.  Once we have drawn these boxes then any point on the left can only be within delta of a finite number of boxes on the right.  If we imagine drawing these boxes all the way down and all the way up.  You don't have to consider all of these boxes.  If you move too far up or down.
10:02:30 If you think of the box this point is in if you move more than three rows up or down any points up there have to be a distance at least a delta apart from this point.  From this particular point we only have to consider the three rows of boxes above or be low.  I think these three, you may be able to restrict it less than that.  We don't have to consider things here.  We only consider things in this part of the right-hand side.  Because there's at most one point in each box,
10:03:14 What that means is if we sort these points by Y coordinate if we look at say the point from this box we only have to consider finitely many points further up in the list.  We have this one which is the closest in terms of Y coordinate.  We only have to consider a certain number of points beyond that and a certain number of points before that in this assorted list by the Y coordinate.  What we will do then is we will sort these points in the strip hereby Y coordinate.
10:03:55 Then we are going to check that all the constant number of points that are within these rows are within distance delta or not.  If any of them are closer than the pair on the left or right then that will be the closest pair.  We will keep track of that.  We only have to compare this point on the left against a constant number of points on the right.  That will prevent this from taking quadratic time.  What we will do is, I will write that down.
10:05:11 We will take the points on the right-hand side of the tube that we didn't filter out  earlier.  Just the things on this tube.  Right tube.  Consider them in Y coordinate order.  What we can do for that is again at the beginning of the algorithm when we sort by X coordinate we can sort them by Y coordinate so we already have that and we can quickly go through and find all the points in this tube now in Y coordinate order.  We will sort all the points by Y
10:06:12 At the beginning of the algorithm.  So we can do this in linear time.  Sorry I misspoke slightly here.  In order to make sure, if we did it the way I described I said it slightly wrong.  If we consider for a particular point here all the points within three rows on the right-hand side then that would require us to go through and find which box on the other side corresponds to this one.  Find which point is closest to that.  There's an easier way to implement this.
10:06:51 Instead we sort all the points in this tube.  Not just on the right-hand side.  We just do the ones on the left-hand side.  When it says sort all points by Y I mean in addition to X.  We keep two arrays.  One is assorted by X and one assorted by Y.  I should say in the left and right tubes.  We will take all the points within this distance delta on left and right.  We will sort them in Y order.  We don't have to sort them at every level.
10:07:24 Because we assume we sort everything by Y at the beginning of the algorithm.  We have all the points in the entire space assorted by X in one array.  We have another array of them assorted by Y.  All the set of points.  What we are going to do is go through first of all we will filter all the points which are not within this tube.  They are not within distance delta of the dividing line.  We go through all the points.  Linear time.  We remove all them which aren't in the center tube.
10:07:56 Now we consider them in Y coordinate order.  The point of these boxes -- the sorting is not linear time.  We do sorting one time at the beginning of the algorithm.  Now all we have to do at this point is go through and linearly filter out all the ones to are not in the tube.  We don't want to do the sorting at every recursive stage because that's N log N.  That's why I say at the beginning of the algorithm we sort them by Y.
10:08:43 Now we go through in linear time in Y order all the points in in region.  The argument of these boxes is for each point we are considering we only need to compute its distance to some constant number of following points.  In this box if we sort them by Y coordinate we only have to consider things in one, two, three, four, five, six through fifteen boxes at most.  I think you can reduce that.  Beyond three rows here.  Your distance has to be more than delta.
10:09:58 It suffices for each point we are considering to only compare it to the following fifteen points in this order as we are going up in Y.  For each point compute its distance to the next fifteen points in the order.  Keeping track of the closest pair that you find.  The argument which I will not do completely formally here.  I want to give you the idea.  It's in the text book.  If you look at these next fifteen points in the order as you are going up in Y here.
10:10:48 Let's say from this point we check this is the next point.  That's the next one, et cetera.  The argument is if there is appoint within distance delta from this one it has to be one of the next fifteen points.  In the worst case if all these boxes from full, you had appoint in every one of these boxes.  In that case, then the point within delta has to be within one of these next fifteen points.  If we have fifteen it has to be one of these.  If you go beyond that point you have to be more than t
10:11:26 Three rows above because there's at most one point per box.  If you take fifteen points further up by the Y coordinate you have to move beyond three rows.  You have to be at distance greater than delta away from this point.  There's at most one point per box.  If you move sixteen points further north in the order by increasing Y you have to be at least four rows.  You have to be up here four rows higher than your original point.
10:11:56 You can't be within distance delta of that point.  Where as with three rows you could be.  If this point was on the edge here and there's one on the edge there they could be delta apart from each other.  If one point is in this row and the other is four rows above it up here no matter where they are in those two boxes they have to be at distance greater than delta from each other.  It suffices to check just the next fifteen points in increasing Y order.
10:13:11 To conclude this if we find a pair which is closer than delta then return the closest such pair.  Other wise, return the pair at distance delta.  If we find a pair within this tube that's closest then it's closer than either of the pairs the recursive calls found so we return that one.  Other wise if doing all the checking of fifteen points for each thing fails to find something closer than delta then it's the recursive calls that find the closest pair and we just return that.
10:13:44 A couple of questions here.  One is, if there's four rows of four boxes isn't it sixteen points?  It's fifteen because one is the point itself.  This point we have to compare this to the following fifteen points.  This box is the point we are currently considering.  Then there's fifteen more boxes we have to consider.  That's why we look at the next fifteen points of the array.  You can reduce this fifteen by doing a sophisticated argument.
10:14:22 It's in CL RS they reduce it to nine.  The point is it's a constant number of points you have to check against.  Not linear.  That's going to save us from doing a quadratic amount of work.  We go through each tube and compare it to constant number of points instead of all the points which is quadratic.  Another question here is how do we go through these points in Y order efficiently.  The idea is we don't want to repeat N log N sorting every time.
10:14:56 We do that once at the beginning of the algorithm.  Sort all the points by the Y coordinate at the beginning.  Then what we can do is a single linear time pass to pull out from that list in order all of the ones who's X coordinate is within delta of the dividing line.  These in the middle.  That's a linear time to go through the assorted array and check which ones are the X coordinate is in the correct range to be in this tube.  That's a linear time check.
10:15:34 Then we have a assorted array by Y coordinate of just the things in this tube.  This let's us do this check and compare to the next fifteen points.  Question.  Right.  Can we optimize this by ignoring points in boxes on the same side?  You are right.  You can.  If we are checking this point here these points there's no point comparing against those because we recursively done that.  You could skip those and not compute distances to those.
10:16:09 For this argument of saying how far along the array you need to checks like the next fifteen points these points could contribute to that.  If these boxes are full you have to look further along the array to get it's points here.  You don't have to compute distances to these again.  You can skip them on the left-hand side of the dividing line.  That doesn't change the asymptotic.  You are computing fewer distances.  Out of the fifteen distances maybe you can skip some.
10:17:14 This is another example of divide and conquer algorithm.  Let's see what the run time of this algorithm is to finish up.  What's the run time?  We have the two.  We have sorting by X and Y at the beginning.  If we use merge sort for that each takes theta of N log N time.  We do it once by X and once by Y that's still N log N.  The recursive part.  We have two recursive calls for the left-hand side and right-hand side.  Plus, we have a linear amount of other work.
10:18:07 Filtering out the points that aren't in the left and rite tube.  For each point we go through again linearly we compare it to fifteen other points that are constant.  There's linear work to filter out the points.  Plus a linear enumeration with fifteen comparisons each.  For each point that we go through we have to compute fifteen distances to it.  It's a constant number.  Again, it's all linear in total.  We have some linear path for filtering things out.
10:18:55 We have a linear loop with a constant amount of work in each iteration.  That's linear in total.  We get the recurrence for a problem of size N we are looking at two problems of size N over two plus a linear amount.  We have seen this recurrence before.  This is the same recurrence we had for merge sort.  The solution is N log N.  In total we have a couple of sorting calls at the beginning which are N log N.  The recursive part is N log N as well.
10:19:45 The over all algorithm is N log N in total.  This has improved on the naive algorithm where we compare all possible pairs of points to each other.  Shouldn't this theta N log N be added to the recurrence?  No we are only doing this at the beginning.  There's two stages.  First we do the N log N sorting then there's the recursive part of the algorithm which only does a linear amount of work at each level of the this is only the run time of the recursive part.
10:20:28 After we finished doing sorting.  The solution to the recurrence as you recall from the merge sort example we did.  You can plug this to the master theorem but it's the same recurrence we saw for merge sort in section.  The solution is N log N.  The total time needed by the algorithm is two sorting calls that are N log N each plus this recursive part which is N log N.  The total time is N log N.  If we had done a constant amount of work at each level this would be a constant.  We are doinly
10:21:20 A linear amount of work.  We have to find the work in the tubes and compare them to the fifteen points.  That's all linear.  Any further questions on this algorithm?  Okay.  I didn't formally prove the correctness of this.  If you want to see the details of why fifteen is enough please check out the text book.  It has more detailed discussion including pseudo code that may help explain this.  The essential idea which is what I want you to understand
10:21:50 It's also the case in divide and conquer algorithms we have to make sure we have a way of taking the solutions for the subproblems and combining those in to a solution for the over all problem.  In this case, the difficulty was that the subproblems were only finding the close e- pair on the left-hand side and right-hand side.  We needed some way to account for pairs on the left and right.  Here we thought of this clever argument.
10:22:27 Which let's us check for all possible pairs to are within distance delta on the left and right side in only linear time.  It's essential here we have a constant value for delta.  We knew how far out to look for this dividing line from the results of the subproblems.  Here delta L and R which we got from the recursive calls tell us how to filter out the points that aren't sufficiently close to this dividing line.  We use the result of the subproblem to help us
10:23:07 In the recombination procedure of checking for possible points that span this dividing line.  Question.  Will you release the home work solutions?  Yes because some people joined the class late I can't release the solutions until this weekend.  They will be released Sunday morning.  You can look at them at that time.  We only have a few minutes left.  Let me preview what we will look at next week.
10:23:40 Our next major topic is going to be graph algorithms.  Before we get to that point there are some topics about data structures and analysis of run time of data structures we need to cover first.  What we will start out with on Monday is looking at a data structure which you have seen a little bit of potentially in one zero one.  Namely the priority Q.
10:24:40 In one zero one you saw the data structure called the heap.  One of the main applications of heaps is implementing this structure called a priority Q.  It's a way of storing a set of items with a numerical key which indicates its priority.  Priority in the Q.  By convention we say a smaller key equals higher priority.   something could have priority one.  That means it's the most important item.  Maybe you have another item with priority seven.
10:25:18 That's a lower priority item.  The idea of a priority Q is it's a lot like a FQ where you put items in and processing them one at a time in the same order they were added.  The difference here is we process things in priority order.  Something may have been added later on but it has higher priority.  We will process it first.  The idea is this is useful when we want to keep track of a number of items that we are processing.
10:26:38 Like a F I FQ.  We need the ability to insert high priority items that we should process earlier than things already in the Q.  We need to be able to have some things in there that were added quite late but are more important.  We need to process those first.  A priority Q will let us manage these items.  Add new things in.  Get the thing that's the highest priority.  Process that.  Remove it from the Q and so forth.  Next week we will talk about different ways of implement can
10:26:52 Priority Qs and using heaps and array.  We will look at the run time of various operations on these Q's.  All right.  Thank you have a nice weekend.  I will hang around in case you have further questions.
